[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Images as Data",
    "section": "",
    "text": "Hello!\nWelcome to IM946 week 5!\nThis week we are going to be working with images as a form of data.\nLast week we looked at how to import images and photographs and how to read the EXIF metadata that is attached to these images. This week we are going to go thorough a series of examples to show how we can pull out different forms of data from a set of images and use this to create data visualizations.\nI have taken a set of example pictures for us to use for our class today. They are not very interesting pictures and are of me traveling from where I used to live in Hebden Bridge (outside Manchester) to a classroom in Warwick. On my journey I tried to take a picture of what was in front of me every 5 minutes. This dataset is not captured with the intention of linking it to a larger political/economic/environmental issue, rather it was created so that the EXIF metadata was easily extractable and varied.\nToday we are going look at:\n\nWhats the data?\nLoading EXIF Data\nDirect Visulization\nGPS Data\nTime Data\nColor Data\nOCR\nClass Challange!\n\nThe code below is example code of ways in which we can extract and work with code from image files. I would like you to read through the examples and think about if or how they could be useful for your project. Please feel free to ask questions, try it out for yourself, or adapt it for your own work!\nFor CDT students, all these examples are written in R. There is no expectation that you learn R or run this code. Rather, you can treat these as examples of what you can do programmatically with images and think about how you could do something similar in your notebooks.\n\n\nWhats the data?\nBefore diving into what we can do with these images and the EXIF data lets have a look at the images themselves.\n\n\n\n\nlibrary(magick) # load in the libraries we need to work with images\nlibrary(grDevices)\n\npar(mfrow = c(5,10), # set our canvas to plot with 5 rows and 10 columns\n    mar = c(0,0,0,0)) # set no margins around our plots\n\n# there are 49 images to load them all in through a simple loop\nfor(n in 1:49){ \n  picture_path &lt;- paste0('media/photos/', n, '.jpeg')\n  # all the images are named 1.jpg, 2.jpg, ect which makes them very easy to load in!\n  picture &lt;- image_read(picture_path)\n  plot(picture)\n}\n\n\n\n\n\n\n\n\n\n\nFigure 2.1: To get these images ready to use for today’s class, I modified them to make them much smaller using the image_resize(img, \"x500\" ) function. This makes it easier to host online and much quicker to work with in R.\n\n\n\nIf you would like to download a copy of these images to work through these examples you can do this from this link.\n\n\nLoading EXIF Data\nLets start by loading the EXIF data from these photos we can do this using the same tools and libraries that we looked at in last weeks class.\nBuilding a dataframe from EXIF data can sometimes be a little tricky as not all photographs may have the same number of metadata items attached to them. To overcome this challenge we are going to do this the easiest way possible by creating a blank data.frame and then looping through each picture, adding a new row to the dataframe each time.\nTo do this we using the rbind.fill() function from the plyr library as this function allows data.frame with unequal numbers of columns to be combined together. This is a good example of a tricky, and potentially time consuming, data cleaning issue that talked about in Wednesdays class).\n\nlibrary(exiftoolr) # load in our libraries\nlibrary(plyr)\n\nall_exif &lt;- data.frame() # create a blank dataframe\n\nfor(n in 1:49){\n  picture_path &lt;- paste0('media/photos/', n, '.jpeg') # loop through our photos, as above\n  picture_exif &lt;- exif_read(picture_path) # read the EXIF data\n  all_exif &lt;- rbind.fill(all_exif, picture_exif)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSourceFile\nExifToolVersion\nFileName\nDirectory\nFileSize\nFileModifyDate\nFileAccessDate\nFileInodeChangeDate\nFilePermissions\nFileType\nFileTypeExtension\nMIMEType\nJFIFVersion\nHDRGainCurveSize\nHDRGainCurve\nExifByteOrder\nMake\nModel\nOrientation\nXResolution\nYResolution\nResolutionUnit\nSoftware\nModifyDate\nHostComputer\nTileWidth\nTileLength\nYCbCrPositioning\nExposureTime\nFNumber\nExposureProgram\nISO\nExifVersion\nDateTimeOriginal\nCreateDate\nComponentsConfiguration\nShutterSpeedValue\nApertureValue\nBrightnessValue\nExposureCompensation\nMeteringMode\nFlash\nFocalLength\nSubjectArea\nMakerNoteVersion\nRunTimeFlags\nRunTimeValue\nRunTimeScale\nRunTimeEpoch\nAEStable\nAETarget\nAEAverage\nAFStable\nAccelerationVector\nFocusDistanceRange\nImageCaptureType\nLivePhotoVideoIndex\nPhotosAppFeatureFlags\nHDRHeadroom\nAFPerformance\nSignalToNoiseRatio\nPhotoIdentifier\nColorTemperature\nCameraType\nFocusPosition\nSubSecTimeOriginal\nSubSecTimeDigitized\nFlashpixVersion\nColorSpace\nExifImageWidth\nExifImageHeight\nSensingMethod\nSceneType\nExposureMode\nWhiteBalance\nFocalLengthIn35mmFormat\nSceneCaptureType\nLensInfo\nLensMake\nLensModel\nCompositeImage\nGPSLatitudeRef\nGPSLongitudeRef\nGPSAltitudeRef\nGPSTimeStamp\nGPSSpeedRef\nGPSSpeed\nGPSImgDirectionRef\nGPSImgDirection\nGPSDestBearingRef\nGPSDestBearing\nGPSDateStamp\nGPSHPositioningError\nProfileCMMType\nProfileVersion\nProfileClass\nColorSpaceData\nProfileConnectionSpace\nProfileDateTime\nProfileFileSignature\nPrimaryPlatform\nCMMFlags\nDeviceManufacturer\nDeviceModel\nDeviceAttributes\nRenderingIntent\nConnectionSpaceIlluminant\nProfileCreator\nProfileID\nProfileDescription\nProfileCopyright\nMediaWhitePoint\nRedMatrixColumn\nGreenMatrixColumn\nBlueMatrixColumn\nRedTRC\nChromaticAdaptation\nBlueTRC\nGreenTRC\nImageWidth\nImageHeight\nEncodingProcess\nBitsPerSample\nColorComponents\nYCbCrSubSampling\nRunTimeSincePowerUp\nAperture\nImageSize\nMegapixels\nScaleFactor35efl\nShutterSpeed\nSubSecCreateDate\nSubSecDateTimeOriginal\nGPSAltitude\nGPSDateTime\nGPSLatitude\nGPSLongitude\nCircleOfConfusion\nFOV\nFocalLength35efl\nGPSPosition\nHyperfocalDistance\nLightValue\nLensID\nXMPToolkit\nCreatorTool\nDateCreated\nRegionAreaY\nRegionAreaW\nRegionAreaX\nRegionAreaH\nRegionAreaUnit\nRegionType\nRegionExtensionsAngleInfoYaw\nRegionExtensionsAngleInfoRoll\nRegionExtensionsConfidenceLevel\nRegionExtensionsFaceID\nRegionAppliedToDimensionsH\nRegionAppliedToDimensionsW\nRegionAppliedToDimensionsUnit\n\n\n\n\nmedia/photos/1.jpeg\n13.44\n1.jpeg\nmedia/photos\n75614\n2024:02:25 14:10:35+\n2026:02:12 14:53:45+\n2026:02:12 14:53:40+\n100644\nJPEG\nJPG\nimage/jpeg\n1 1\n251\n3691 7683 11382 1502\nMM\nApple\niPhone XS Max\n1\n72\n72\n2\n16.3.1\n2024:02:09 07:38:05\niPhone XS Max\n512\n512\n1\n0.01666666667\n1.8\n2\n320\n0232\n2024:02:09 07:38:05\n2024:02:09 07:38:05\n1 2 3 0\n0.0165679999782223\n1.79999999993144\n1.510567669\n0\n5\n16\n4.25\n2013 1511 2217 1393\n14\n1\n176357126276750\n1000000000\n0\n1\n186\n191\n1\n-0.03880077602 -1.00\n2.9609375 2.30078125\n10\n13639680\n0\n1.686418056\n157 268435570\n33.00339506\n0C54A3EE-31E2-43C9-A\n7531\n1\n59\n758\n758\n0100\n65535\n4032\n3024\n2\n1\n0\n0\n26\n0\n4.25 6 1.8 2.4\nApple\niPhone XS Max back d\n2\nN\nW\n0\n20:00:00\nK\n0.02899493462\nT\n253.1574557\nT\n253.1574557\n2024:02:09\n13.7876972\nappl\n1024\nmntr\nRGB\nXYZ\n2022:01:01 00:00:00\nacsp\nAPPL\n0\nAPPL\n\n0 0\n0\n0.9642 1 0.82491\nappl\n236 253 163 142 56 1\nDisplay P3\nCopyright Apple Inc.\n0.96419 1 0.82489\n0.51512 0.2412 -0.00\n0.29198 0.69225 0.04\n0.1571 0.06657 0.784\nbase64:cGFyYQAAAAAAA\n1.04788 0.02292 -0.0\nbase64:cGFyYQAAAAAAA\nbase64:cGFyYQAAAAAAA\n375\n500\n0\n8\n3\n2 2\n176357.12627675\n1.8\n375 500\n0.1875\n6.11764705882353\n0.01666666667\n2024:02:09 07:38:05.\n2024:02:09 07:38:05.\n110.8395769\n2024:02:09 20:00:00Z\n53.7416444444444\n-2.01625555555556\n0.00491140798741088\n69.3903656740024\n26\n53.7416444444444 -2.\n2.04314572276293\n5.92481250331724\niPhone XS Max back d\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n\n\nmedia/photos/2.jpeg\n13.44\n2.jpeg\nmedia/photos\n79574\n2024:02:25 14:10:35+\n2026:02:12 14:53:45+\n2026:02:12 14:53:42+\n100644\nJPEG\nJPG\nimage/jpeg\n1 1\n251\n3304 6809 10550 1441\nMM\nApple\niPhone XS Max\n1\n72\n72\n2\n16.3.1\n2024:02:09 07:42:56\niPhone XS Max\n512\n512\n1\n0.01666666667\n1.8\n2\n160\n0232\n2024:02:09 07:42:56\n2024:02:09 07:42:56\n1 2 3 0\n0.0165679999782223\n1.79999999993144\n2.564540738\n0\n5\n16\n4.25\n2013 1511 2217 1393\n14\n1\n176608655067208\n1000000000\n0\n1\n173\n176\n1\n0.0218595639 -1.0003\n0.7265625 0.4296875\n10\n13639680\n0\n1.686418056\n105 268435497\n36.20163728\n6D38E07B-7BF2-4836-9\n7531\n1\n59\n168\n168\n0100\n65535\n4032\n3024\n2\n1\n0\n0\n26\n0\n4.25 6 1.8 2.4\nApple\niPhone XS Max back d\n2\nN\nW\n0\n20:00:00\nK\n2.097243071\nT\n112.0013657\nT\n112.0013657\n2024:02:09\n33.24521744\nappl\n1024\nmntr\nRGB\nXYZ\n2022:01:01 00:00:00\nacsp\nAPPL\n0\nAPPL\n\n0 0\n0\n0.9642 1 0.82491\nappl\n236 253 163 142 56 1\nDisplay P3\nCopyright Apple Inc.\n0.96419 1 0.82489\n0.51512 0.2412 -0.00\n0.29198 0.69225 0.04\n0.1571 0.06657 0.784\nbase64:cGFyYQAAAAAAA\n1.04788 0.02292 -0.0\nbase64:cGFyYQAAAAAAA\nbase64:cGFyYQAAAAAAA\n375\n500\n0\n8\n3\n2 2\n176608.655067208\n1.8\n375 500\n0.1875\n6.11764705882353\n0.01666666667\n2024:02:09 07:42:56.\n2024:02:09 07:42:56.\n101.0746739\n2024:02:09 20:00:00Z\n53.7405083333333\n-2.01409444444444\n0.00491140798741088\n69.3903656740024\n26\n53.7405083333333 -2.\n2.04314572276293\n6.92481250331724\niPhone XS Max back d\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n\n\nmedia/photos/3.jpeg\n13.44\n3.jpeg\nmedia/photos\n103244\n2024:02:25 14:10:36+\n2026:02:12 14:53:45+\n2026:02:12 14:53:42+\n100644\nJPEG\nJPG\nimage/jpeg\n1 1\n251\n8069 15882 23790 316\nMM\nApple\niPhone XS Max\n1\n72\n72\n2\n16.3.1\n2024:02:09 07:48:53\niPhone XS Max\n512\n512\n1\n0.04\n1.8\n2\n320\n0232\n2024:02:09 07:48:53\n2024:02:09 07:48:53\n1 2 3 0\n0.0399920000731997\n1.79999999993144\n-0.0478944311\n0\n5\n16\n4.25\n2013 1511 2217 1393\n14\n1\n176878939595083\n1000000000\n0\n1\n172\n166\n1\n0.0207697507 -0.9942\n1.59765625 1.09375\n10\n13639680\n0\n0\n67 268435563\n28.24822425\n25F6B2C6-8939-4EA6-8\n2858\n1\n65\n566\n566\n0100\n65535\n4032\n3024\n2\n1\n0\n0\n26\n0\n4.25 6 1.8 2.4\nApple\niPhone XS Max back d\n2\nN\nW\n0\n20:00:00\nK\n0\nT\n244.7424623\nT\n244.7424623\n2024:02:09\n8.590117966\nappl\n1024\nmntr\nRGB\nXYZ\n2022:01:01 00:00:00\nacsp\nAPPL\n0\nAPPL\n\n0 0\n0\n0.9642 1 0.82491\nappl\n236 253 163 142 56 1\nDisplay P3\nCopyright Apple Inc.\n0.96419 1 0.82489\n0.51512 0.2412 -0.00\n0.29198 0.69225 0.04\n0.1571 0.06657 0.784\nbase64:cGFyYQAAAAAAA\n1.04788 0.02292 -0.0\nbase64:cGFyYQAAAAAAA\nbase64:cGFyYQAAAAAAA\n375\n500\n0\n8\n3\n2 2\n176878.939595083\n1.8\n375 500\n0.1875\n6.11764705882353\n0.04\n2024:02:09 07:48:53.\n2024:02:09 07:48:53.\n105.9569265\n2024:02:09 20:00:00Z\n53.7378888888889\n-2.00883055555556\n0.00491140798741088\n69.3903656740024\n26\n53.7378888888889 -2.\n2.04314572276293\n4.66177809777199\niPhone XS Max back d\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n\n\nmedia/photos/4.jpeg\n13.44\n4.jpeg\nmedia/photos\n56051\n2024:02:25 14:10:36+\n2026:02:12 14:53:45+\n2026:02:12 14:53:42+\n100644\nJPEG\nJPG\nimage/jpeg\n1 1\n251\n12438 24946 37155 49\nMM\nApple\niPhone XS Max\n1\n72\n72\n2\n16.3.1\n2024:02:09 07:53:55\niPhone XS Max\n512\n512\n1\n0.01666666667\n1.8\n2\n250\n0232\n2024:02:09 07:53:55\n2024:02:09 07:53:55\n1 2 3 0\n0.0165679999782223\n1.79999999993144\n1.583796104\n0\n5\n16\n4.25\n2013 1511 2217 1393\n14\n1\n177066956766750\n1000000000\n0\n1\n169\n164\n1\n0.07634519039 -0.791\n4.1171875 3.36328125\n10\n13639680\n0\n0\n8 268435797\n33.22625733\n37AC8A42-8D1C-4BCF-B\n6618\n1\n231\n658\n658\n0100\n65535\n4032\n3024\n2\n1\n0\n0\n26\n0\n4.25 6 1.8 2.4\nApple\niPhone XS Max back d\n2\nN\nW\n0\n20:00:00\nK\n0.2655441764\nT\n86.43673707\nT\n86.43673707\n2024:02:09\n17.58620243\nappl\n1024\nmntr\nRGB\nXYZ\n2022:01:01 00:00:00\nacsp\nAPPL\n0\nAPPL\n\n0 0\n0\n0.9642 1 0.82491\nappl\n236 253 163 142 56 1\nDisplay P3\nCopyright Apple Inc.\n0.96419 1 0.82489\n0.51512 0.2412 -0.00\n0.29198 0.69225 0.04\n0.1571 0.06657 0.784\nbase64:cGFyYQAAAAAAA\n1.04788 0.02292 -0.0\nbase64:cGFyYQAAAAAAA\nbase64:cGFyYQAAAAAAA\n375\n500\n0\n8\n3\n2 2\n177066.95676675\n1.8\n375 500\n0.1875\n6.11764705882353\n0.01666666667\n2024:02:09 07:53:55.\n2024:02:09 07:53:55.\n107.8988345\n2024:02:09 20:00:00Z\n53.7379305555556\n-2.00911388888889\n0.00491140798741088\n69.3903656740024\n26\n53.7379305555556 -2.\n2.04314572276293\n6.28095631354252\niPhone XS Max back d\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n\n\nmedia/photos/5.jpeg\n13.44\n5.jpeg\nmedia/photos\n114105\n2024:02:25 14:10:36+\n2026:02:12 14:53:45+\n2026:02:12 14:53:42+\n100644\nJPEG\nJPG\nimage/jpeg\n1 1\n251\n13268 26261 38926 51\nMM\nApple\niPhone XS Max\n1\n72\n72\n2\n16.3.1\n2024:02:09 07:59:26\niPhone XS Max\n512\n512\n1\n0.02\n1.8\n2\n200\n0232\n2024:02:09 07:59:26\n2024:02:09 07:59:26\n1 2 3 0\n0.0199939999476312\n1.79999999993144\n1.729386043\n0\n5\n16\n4.25\n2013 1511 2217 1393\n14\n1\n177392672294583\n1000000000\n0\n0\n190\n166\n1\n-0.0090702204 -1.004\n5.14453125 2.3046875\n10\n13639680\n0\n1\n112 268435591\n33.62224582\nD001CCA7-8D00-4C1F-9\n6777\n1\n54\n889\n889\n0100\n65535\n4032\n3024\n2\n1\n0\n0\n26\n0\n4.25 6 1.8 2.4\nApple\niPhone XS Max back d\n2\nN\nW\n0\n20:00:00\nK\n0.6883943678\nT\n314.2805789\nT\n314.2805789\n2024:02:09\n28.84374421\nappl\n1024\nmntr\nRGB\nXYZ\n2022:01:01 00:00:00\nacsp\nAPPL\n0\nAPPL\n\n0 0\n0\n0.9642 1 0.82491\nappl\n236 253 163 142 56 1\nDisplay P3\nCopyright Apple Inc.\n0.96419 1 0.82489\n0.51512 0.2412 -0.00\n0.29198 0.69225 0.04\n0.1571 0.06657 0.784\nbase64:cGFyYQAAAAAAA\n1.04788 0.02292 -0.0\nbase64:cGFyYQAAAAAAA\nbase64:cGFyYQAAAAAAA\n375\n500\n0\n8\n3\n2 2\n177392.672294583\n1.8\n375 500\n0.1875\n6.11764705882353\n0.02\n2024:02:09 07:59:26.\n2024:02:09 07:59:26.\n109.6631615\n2024:02:09 20:00:00Z\n53.7378305555556\n-2.00918888888889\n0.00491140798741088\n69.3903656740024\n26\n53.7378305555556 -2.\n2.04314572276293\n6.33985000288463\niPhone XS Max back d\nXMP Core 6.0.0\n16.3.1\n2024:02:09 07:59:26\n0.68385714285714294\n0.026190476190476208\n0.53928571428571437\n0.034571428571428586\nnormalized\nFace\n0\n90\n80\n2\n3024\n4032\npixel\n\n\nmedia/photos/6.jpeg\n13.44\n6.jpeg\nmedia/photos\n108813\n2024:02:25 14:10:37+\n2026:02:12 14:53:45+\n2026:02:12 14:53:42+\n100644\nJPEG\nJPG\nimage/jpeg\n1 1\n251\n13239 26702 40488 54\nMM\nApple\niPhone XS Max\n1\n72\n72\n2\n16.3.1\n2024:02:09 08:04:39\niPhone XS Max\n512\n512\n1\n0.02040816327\n1.8\n2\n200\n0232\n2024:02:09 08:04:39\n2024:02:09 08:04:39\n1 2 3 0\n0.0205200000829189\n1.79999999993144\n1.789725209\n0\n5\n16\n4.25\n2013 1511 2217 1393\n14\n1\n177704726360250\n1000000000\n0\n0\n170\n177\n1\n-0.08329442888 -0.80\n1.33984375 3.8007812\n10\n13639680\n0\n1.568873048\n60 268435526\n33.80025099\n25F23E88-98E6-4CC7-A\n6560\n1\n67\n020\n020\n0100\n65535\n4032\n3024\n2\n1\n0\n0\n26\n0\n4.25 6 1.8 2.4\nApple\niPhone XS Max back d\n2\nN\nW\n0\n20:00:00\nK\n0\nT\n292.9943236\nT\n292.9943236\n2024:02:09\n55\nappl\n1024\nmntr\nRGB\nXYZ\n2022:01:01 00:00:00\nacsp\nAPPL\n0\nAPPL\n\n0 0\n0\n0.9642 1 0.82491\nappl\n236 253 163 142 56 1\nDisplay P3\nCopyright Apple Inc.\n0.96419 1 0.82489\n0.51512 0.2412 -0.00\n0.29198 0.69225 0.04\n0.1571 0.06657 0.784\nbase64:cGFyYQAAAAAAA\n1.04788 0.02292 -0.0\nbase64:cGFyYQAAAAAAA\nbase64:cGFyYQAAAAAAA\n375\n500\n0\n8\n3\n2 2\n177704.72636025\n1.8\n375 500\n0.1875\n6.11764705882353\n0.02040816327\n2024:02:09 08:04:39.\n2024:02:09 08:04:39.\n109.6561203\n2024:02:09 20:00:00Z\n53.7378055555556\n-2.00898055555556\n0.00491140798741088\n69.3903656740024\n26\n53.7378055555556 -2.\n2.04314572276293\n6.31070365689329\niPhone XS Max back d\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n\n\n\n\n\nFigure 3.1: Note: To make this table easier to read online I’ve clipped each cell to show a maximum of 20 characters for the top 5 rows of the dataframe.\n\n\n\nIf you would like to download just a copy of this dataframe you can do this use this link\n\n\nDirect Visulization\nThe first thing we can explore is using some of this EXIF data is to play around with direct visulization techniques, as we saw in the Lev Manovich article.\nSince my photos are not (yet) connected to a bigger issue we are going to use the variable GPSHPositioningError and see how this changes across the pictures. We are going to start off simply and just use an if statement built into a loop. We are using the same loop we used to load in all our pictures above, and then plotting them with an opacity and a color, either blue or orange, laid over the top.\n\npar(mfrow = c(5,10),\n    mar = c(0,0,0,0))\n\nfor(n in 1:49){\n  picture &lt;- image_read(all_exif[n,]$SourceFile) # now we have the exif data we \n  # have changed this command use the 'SourceFile' variable from the dataframe\n  \n  gps_error &lt;- all_exif[n,]$GPSHPositioningError # set the variable\n  \n  if (gps_error &lt;= 500){ \n    plot(image_colorize(picture,\n                        opacity = 50,\n                        color = 'blue'))\n    }\n  \n  if (gps_error &gt;= 500){\n    plot(image_colorize(picture,\n                        opacity = 50,\n                        color = 'orange'))\n    }\n}\n\n\n\n\n\n\n\n\nWe now have a direct data visulization! But or classification is quite simple. We can make this a little more interesting by using a color spectrum.\nWe can use the colorRampPalette function to achieve this. Our palette is going to run from blue to orange again. To set our color ramp we are going to set it against the max value (using the max() function). In this case it will create a color ramp with 11,000 colors! But when we plot them altogether it will give us a nice smooth gradient that looks like this:\n\n\n\n\n\n\n\n\n\nWe can then incorporate this into our loop (taking out the if statements) and setting the color of each photo by putting our color_ramp and GPSHPositioningError values together.\n\ncolfunc &lt;- colorRampPalette(c('blue', 'orange'))\ncolour_ramp &lt;- colfunc(max(all_exif$GPSHPositioningError))\n\npar(mfrow = c(5,10),\n    mar = c(0,0,0,0))\n\nfor(n in 1:49){\n\n    picture_path &lt;- paste0(all_exif[n,]$SourceFile)\n  picture &lt;- image_read(picture_path)\n  \n  gps_error &lt;- all_exif[n,]$GPSHPositioningError\n  \n  plot(image_colorize(picture,\n                      opacity = 50,\n                      color = colour_ramp[gps_error]))\n  }\n\n\n\n\n\n\n\n\nOh! this isn’t quite what we were expecting.\nIt looks like we have one extreme value that is throwing off our nice color ramp. (For the keen eyed or frequent travelers its Wolverhampton station).\nWe could do a quick bit of Exploratory Data Analysis to learn some more about the distribution of our values, for example with a box and whisker plot:\n\n\n\n\n\n\n\n\n\nTo overcome this issue we can classify our variable according to a set of intervals. We have looked at variable splits in other classes, and there are lots of other ways of doing this (I am a big fan of this example).\nTo do this we are going to use the classInt library and the cut() function and assign the results to a new variable in our dataframe we are calling error_cats.\n\nlibrary(classInt)\n\nintervals &lt;- classIntervals(all_exif$GPSHPositioningError,\n                            n = 5)\n\nall_exif$error_cats &lt;- cut(all_exif$GPSHPositioningError, \n                           breaks = intervals$brks,\n                           include.lowest = TRUE,\n                           labels=c(1:5))\n\ncolfunc &lt;- colorRampPalette(c('blue', 'orange'))\ncolour_ramp &lt;- colfunc(5)\n\npar(mfrow = c(5,10),\n    mar = c(0,0,0,0))\n\nfor(n in 1:49){\n  picture_path &lt;- paste0(all_exif[n,]$SourceFile)\n  picture &lt;- image_read(picture_path)\n  \n  plot(image_colorize(picture,\n                      opacity = 50,\n                      color = colour_ramp[all_exif[n,]$error_cats])\n       )\n}\n\n\n\n\n\n\n\n\nFinally, we could change the order in which we are plotting our data. We can use the order() function to do this. Since we are using a loop, however, we do not need to re-order our data, we can simply create vector that loops through our pictures in an order defined by the GPSHPositioningError rank.\n\n# We can use the order function to do this for us \n\ngps_error_order &lt;-rownames(all_exif[order(all_exif$GPSHPositioningError),])\n\npar(mfrow = c(5,10),\n    mar = c(0,0,0,0))\n\nfor(n in gps_error_order){ # changing the order\n  picture_path &lt;- paste0(all_exif[n,]$SourceFile)\n  picture &lt;- image_read(picture_path)\n  \n  plot(image_colorize(picture,\n                      opacity = 50,\n                      color = colour_ramp[all_exif[n,]$error_cats])\n  )\n}\n\n\n\n\n\n\n\n\n\n\nGPS Data\nOur EXIF metadata data also includes GPS data. In its simplest form, GPS data is just a set of coordinates, one x and one y this means we don’t even need a maps package to plot it. We can send these coordinates straight to the plot function to see what they look like.\n\npar(mfrow = c(1,1))\n\nplot(all_exif$GPSLongitude, all_exif$GPSLatitude,\n       pch=19, cex=1, col=\"red\")\n\n\n\n\n\n\n\n\nWhile this is easy to plot, its not very decipherable. To make my journey a little easier to understand we can turn this into a line plot and include a sequence of numbers alongside.\n\ncolfunc &lt;- colorRampPalette(c('blue', 'orange'))\ncolour_ramp &lt;- colfunc(49)\n\nplot(all_exif$GPSLongitude, all_exif$GPSLatitude,\n      type = \"l\",\n      col = 'grey',\n      )\ntext(all_exif$GPSLongitude, all_exif$GPSLatitude,\n     labels = row(all_exif)[,1],\n     col = colour_ramp[row(all_exif)[,1]])\n\n\n\n\n\n\n\n\nStill not great, but it makes a little more sense. Lets bring this altogether and plot our images and our graph side by side. This next section gets a little complicated in how we are setting out our canvas in R, so don’t be overwhelmed if it doesn’t make immediate sense! (This may be very helpful to come back to later depending on what software you want to use to approach this project).\nWe can use par(omd=) to set up a par window within our canvas we can then call par() again to set out our 5x10 picture grid.\nUsing the other side of the canvas is a little more complicated. We need to use par(omd=) to specify the other side of the canvas. Then set out the number of rows again using par(mfrow=), in this case we just want 1 plot. Finally we have to use par(mfg=) so that our canvas does not reset when we call plot again.\n\npar(omd=c(0,0.5,0,1),\n    mfrow = c(5,10),\n    mar = c(0,0,0,0))\n\nfor(n in 1:49){\n  picture_path &lt;- paste0(all_exif[n,]$SourceFile)\n  picture &lt;- image_read(picture_path)\n  plot(picture)\n  text(200,250, # lets add in text to show the order of the pictures\n       labels = n,\n       cex= 3,\n       col = colour_ramp[row(all_exif)[,1]]) # and add in the color data\n}\n \npar(omd=c(0.5,1,0,1),\n    mfrow=c(1, 1),\n    mfg=c(1, 1))\n\nplot(all_exif$GPSLongitude, all_exif$GPSLatitude,\n     pch=19, cex=1,\n     col = colour_ramp[all_exif$error_cats],\n     axes = F\n)\nlines(all_exif$GPSLongitude, all_exif$GPSLatitude,\n      type = \"l\",\n      col = 'grey',\n)\n\ntext(all_exif$GPSLongitude, all_exif$GPSLatitude,\n     labels = row(all_exif)[,1],\n     col = colour_ramp[all_exif$error_cats],\n     pos = 3,\n     offset = 0.3)\n\n\n\n\n\n\n\n\nSo far we have worked with our spatial data by simply reading our GPS coordinates into R just as they are. However this doesn’t look quite right as the points are stretched out and our axis are scaled according the the minimum and maximum values in our data rather than the fixed grid of longitude and latitude. We could fix this by playing around with the scale of our axis. However, the easier way to address this issue is by treating our GPS metadata as spatial data.\nTo work with this data as proper ‘spatial data’ we need to read it with a library that treats space in a more complex way. To do this we are going to us the sf library.\nTo start with we are going to read in a shapefile of the UK local authorities. We can then use this as an example that we can match up to our photo data.\n\n\n\n\nlibrary(sf)\nla_data &lt;- st_read('media/Local_authorites/LAD_DEC_2023_UK_BUC.shp')\n\nReading layer `LAD_DEC_2023_UK_BUC' from data source \n  `/Users/u2272744/Dropbox/30 - 39 - Personal Teaching/32 - Data Visualization/32.IM942.2526 - Adv Viz/32.IM942.2526 - Adv Viz - Week 5 - Class/IMAGES_AS_DATA/media/local_authorites/LAD_DEC_2023_UK_BUC.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 361 features and 8 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -116.1928 ymin: 7054.1 xmax: 655653.8 ymax: 1220310\nProjected CRS: OSGB36 / British National Grid\n\npar(omd=c(0,1,0,1))\npar(mfrow=c(1,1))\n\nplot(la_data)\n\n\n\n\n\n\n\n\n\n\nFigure 5.1: If you are curious about administrative boundaries, what these variable names mean, and how to work with spatial data in detail we will be exploring this further in project 3.\n\n\n\nNow we can convert our EXIF data into a a spatial data format. The sf package provides easy tools to do this with. But first lets make a subset of this data as we don’t need all of the variables from the EXIF data file.\n\nall_exif_sf &lt;- all_exif[, c(\"SourceFile\", \"GPSLongitude\", \"GPSLatitude\")]\n\n# And then convert this into a 'spatial' data.frame\n\nall_exif_sf &lt;- st_as_sf(all_exif_sf,\n                        coords=c(\"GPSLongitude\", \"GPSLatitude\"),\n                        crs=st_crs(4326)) # I will explain this number soon!\n\nplot(all_exif_sf)\n\n\n\n\n\n\n\n\nNotice how, now we have converted our data into a spatial dataframe, that the points are not as stretched as when we were plotting them as simple x, y points? This is because base R was adjusting the x axis to fit the min and max of our data. However, as a spatial data format, sf tells R not to do this as it would distort the map!\nNow lets plot the two files together to make sure everything is matching up.\n\nplot(la_data$geometry)\npoints(all_exif$GPSLongitude, all_exif$GPSLatitude, col = 'red')\n\n\n\n\n\n\n\n\nWait, this doesn’t look right. All our points are the red ciricles out in the ocean, and we can tell from looking at the photographs themselves that this was not where they were taken!\nSo what has gone wrong? In this case, there is nothing wrong with the data but there is something off with the format in which the data is being read. When working with geographic data all the underlying points are encoded based on ‘projections’ of the earth. This is how points from a 3D sphere of our planet are translated into the 2D plane we use for making maps.\nIn this case each dataset has a different projection, encoded as the ‘crs’ or ‘coordinate reference system’. The UK data is based on the ‘OSGB36 / British National Grid’ which is used for all official data in the UK. (so created so that when you look at a UK map all the longitude and latitude grid lines are straight rather than being slightly curved). Whereas our the data from my phone is encoded as by the standard global GPS crs known as WGS84.\nWe can align these two projections using st_transform. The number 4326 specifies the WGS84 system.\n\n\n\n\nla_data &lt;- st_transform(la_data, crs=4326)\n\nplot(la_data$geometry)\npoints(all_exif$GPSLongitude, all_exif$GPSLatitude, col = 'red')\n\n\n\n\n\n\n\n\n\n\nFigure 5.2: Notice how the shape of the UK subtlety changes and our points now line up!\n\n\n\nWith our spatial data now matching up correctly we bring the two datasets together by looking at where the data matches.Our GPS coordinates are not only good for plotting where our pictures were taken, but for linking up our photographs to other datasets. We can do this through an operation called points-in-polygons. Essentially we locate where our photos are in the shapes data or ‘polygons’ in the local authorities dataset we have just been ploting.\nWe can find where our points fit within these shapes using the st_intersections() function.\n\nmatching_points &lt;- st_intersection(la_data, all_exif_sf)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLAD23CD\nLAD23NM\nLAD23NMW\nBNG_E\nBNG_N\nLONG\nLAT\nGlobalID\nSourceFile\ngeometry\n\n\n\n\n259\nE08000033\nCalderdale\nNA\n402618\n424895\n-1.9618\n53.7205\naf25e83c-93ad-4a81-bff4-6d5568a7aa4d\nmedia/photos/1.jpeg\nPOINT (-2.016256 53.74164)\n\n\n259.1\nE08000033\nCalderdale\nNA\n402618\n424895\n-1.9618\n53.7205\naf25e83c-93ad-4a81-bff4-6d5568a7aa4d\nmedia/photos/2.jpeg\nPOINT (-2.014094 53.74051)\n\n\n259.2\nE08000033\nCalderdale\nNA\n402618\n424895\n-1.9618\n53.7205\naf25e83c-93ad-4a81-bff4-6d5568a7aa4d\nmedia/photos/3.jpeg\nPOINT (-2.008831 53.73789)\n\n\n259.3\nE08000033\nCalderdale\nNA\n402618\n424895\n-1.9618\n53.7205\naf25e83c-93ad-4a81-bff4-6d5568a7aa4d\nmedia/photos/4.jpeg\nPOINT (-2.009114 53.73793)\n\n\n259.4\nE08000033\nCalderdale\nNA\n402618\n424895\n-1.9618\n53.7205\naf25e83c-93ad-4a81-bff4-6d5568a7aa4d\nmedia/photos/5.jpeg\nPOINT (-2.009189 53.73783)\n\n\n259.5\nE08000033\nCalderdale\nNA\n402618\n424895\n-1.9618\n53.7205\naf25e83c-93ad-4a81-bff4-6d5568a7aa4d\nmedia/photos/6.jpeg\nPOINT (-2.008981 53.73781)\n\n\n\n\n\nUsing the the same loop as we did for the examples above we can now bring these two datasets together and write in the local authority names where each photograph was taken.\n\npar(mfrow = c(5,10), # set our canvas to plot with 5 rows and 10 columns\n    mar = c(0,0,0,0)) # set no margins around our plots\n\nfor(n in 1:49){\n  picture_path &lt;- paste0(all_exif[n,]$SourceFile)\n  picture &lt;- image_read(picture_path)\n  plot(picture)\n  text(200,250, # lets add in text to show the Local Authority\n     labels = matching_points[n,]$LAD23NM, # labeling\n    cex= 1,\n   col = 'red'\n  )\n}\n\n\n\n\n\n\n\n\n\n\nTime Data\nOne of the attributes attached to our photos is time. Time can be very useful for representing all sorts of things about our data! However, time needs to be stored in R as a specific type of value. This example walks through the very basics of working with time and showing how to convert strings into a time format.\nWe can check the type of how or data is stored with typeof() function.\n\ntypeof(all_exif$DateTimeOriginal)\n\n[1] \"character\"\n\n\nAs a character field our time data is currently seen by R as string of letters and numbers while this can be of use for double checking things, it means we cannot plot, add, subtract or visualise this data.\nWe can convert this strings into date formats, known in R as DateTimeClasses with strptime() function. However, we need to specify what the function is looking for. For looking at our data we can see that dates are beings stored as:\n\"2024:02:09 11:58:45\"\nWe can then use special characters, which we specify with %, to tell R what and where our times are:\n\n%Y stands for year\n%m for month\n%d for day\n%H for hour\n%M for minutes\n%S for seconds\n\nThere are many potential options here which you can find out with the ?strptime command.\n\nall_exif$time_formated &lt;- strptime(all_exif$DateTimeOriginal, \"%Y:%m:%d %H:%M:%S\")\n\nNow that R can read time as DateTimeClasses we can do mathematical operations on time just as we would with numbers.\nFor example we can calculate my total journey time from the first picture to the last.\n\ntime_total &lt;- max(all_exif$time_formated) - min(all_exif$time_formated)\n\ntime_total\n\nTime difference of 4.344444 hours\n\n\nAs our time data is now in the right format, we can now visualize it. To create sample data I tried to take a picture every 5 minutes, lets see how successful I was …\nThe code below is an easy way to accomplish this, but it isn’t the ‘best’ or most ‘efficient’ code. Trying to write ‘perfect’ code can often gets in the way of what we trying to archive. The main question we should ask ourselves when we are coding is does this help us accomplish our task?\nAs with all code, there are multiple different ways we can achieve the same result. With the below code, I’ve tried to make things as easy to follow as possible by reusing the loop we used to read in the EXIF data and not load any external libraries for other functions that we could use to achieve the same result. For our purposes today a loop is sufficient and can be an an easy way to get the results we are after.\n\n# lets create a blank data frame, as we loop through our data we will add each\n# new row to the bottom of the data frame\ntime_data &lt;- data.frame()\n\n# we are also going to start from our second value \nfor (n in 2:49){\n  time_dif &lt;- difftime(all_exif[n,]$time_formated,\n                       all_exif[n - 1,]$time_formated, #and then to get the\n                       units = 'secs') # difference we use n - 1 to select the \n                                       # previous value\n  \n  time_dif &lt;- as.numeric(time_dif) # then have our time in seconds\n  \n  # then turn our results into a single row data.frame\n  temp_time_data &lt;- data.frame('SourceFile' = all_exif[n,]$SourceFile, \n                               'time_between' = time_dif)\n                                \n  # add add this to our time_data data.frame \n  time_data &lt;- rbind(time_data, temp_time_data)\n}\n\n# and finally, see how far off I was from the 5 minute mark\n\ntime_data$five &lt;- time_data$time_between - 300\n\n# A simple plot\n\npar(mfrow=c(1,1))\n\nplot(time_data$five, type='h')\n\n\n\n\n\n\n\n\n\n\nColor Data\nSo far we have worked with our pictures by extracting the EXIF data and overlaying information on top or plotting it separately. But the images themselves are made up of data. For this next example we are going to extract color data from our images and plot this on its own, giving us a more abstract representation of our pictures\nTo do this we are going to use the package RImagePalette. There are several packages that can do operations like this, but this one is fast and simple to use so works well for this task. Other packages, can work with extracting color in different more specific ways from images so are worth looking up if you are interested!\nWe are also going to load in our images in a different way using the JPEG library. As it represent our image as a matrix of its underlying data. This means that the RImagePalette can directly perform operations on the underlying data.\n\nlibrary(RImagePalette)\nlibrary(baselines) \n\njpeg_example &lt;- jpeg::readJPEG(paste0(all_exif[1,]$SourceFile))\n\nWe can then use the image_palette() function to pick out the nine most dominant colors from our example picture in a 3x3 grid.\n\ncol_pal &lt;- image_palette(jpeg_example, n=9) \n\npar(mfrow=c(3,3),\n    mar = c(0,0,0,0))\n\nfor (c in col_pal){\n  plot_blank()\n  plot_background(col=c)\n}\n\n\n\n\n\n\n\n\nNow lets scale this up to all of our pictures. I’m going to pick 5 colors and plot them sequentially so we need 5*49 cols. We are a also going to keep a running list of all the colors we generate during this loop for another visualization in the col_pal_all vector.\n\n# I'm going to pick 5 colors and plot them sequentially so we need 5*49 cols\npar(mfrow=c(1,245),\n    mar = c(0,0,0,0))\n\n# We are a also going to keep a running list of all the colors we generate\n# during this loop for another visualization \n\ncol_pal_all &lt;- c()\n\nfor(n in 1:49){\n  picture_path &lt;- paste0(all_exif[n,]$SourceFile)\n  picture &lt;- jpeg::readJPEG(picture_path)\n  col_pal &lt;- image_palette(picture, n=5)\n  for (c in col_pal){\n    plot_blank()\n    plot_background(col=c)\n  }\n  col_pal_all &lt;- append(col_pal_all, col_pal)\n}\n\n\n\n\n\n\n\n\nWith the all our colors in the single vector col_pal_all we can sort them into an order to make a different visulization. However, sorting colors is a non-trivial problem, which this blog post dives into. To avoid this complexity we are going to use the lterpalettefinder library which has a color sorter function we can use for now.\n\nlibrary(lterpalettefinder)\n\ncol_pal_sorted &lt;- palette_sort(col_pal_all)\n\npar(mfrow=c(1,245),\n    mar = c(0,0,0,0))\n\nfor (c in col_pal_sorted){\n  plot_blank()\n  plot_background(col=c)\n}\n\n\n\n\n\n\n\n\n\n\nOCR\nFinally, we can extract data of what is contained in the images themselves, for example all of the text. To do this we are going to use a form of machine learning called OCR, or Optical Character Recognition.\nTo do this we are going use the google tesseract library.\n\n\n\n\nlibrary(tesseract)\n\n# setting the language\ntesseract(language = \"eng\")\n\ntext_data &lt;- data.frame()\n \n# Unlike all our other loops for this task we need higher resolution images\n# so we are loading in our pictures from a different directory\n \n for(n in 1:49){\n   picture_path &lt;- paste0('media/og_photos/', n, '.jpeg')\n   picture &lt;- image_read(picture_path)\n   picture_text &lt;- image_ocr_data(picture)\n   picture_text$source &lt;- all_exif[n,]$SourceFile\n   text_data &lt;- rbind(text_data, picture_text)\n }\n\n\n\nFigure 8.1: Note this step requires higher resolution images which you need to download from the class Teams channel.\n\n\n\nLooking at the text data that has been extracted from the text we can see that lots of it is unusable!\n\n\n\n\n\n…1\nword\nconfidence\nbbox\nsource\n\n\n\n\n1\ni\n50.11905\n2590,0,2613,89\nmedia/photos/1.jpeg\n\n\n2\n!\n35.61607\n2655,8,2676,75\nmedia/photos/1.jpeg\n\n\n3\n“Vb\n64.10910\n2745,0,2814,41\nmedia/photos/1.jpeg\n\n\n4\nJ\n95.34794\n2892,0,2930,98\nmedia/photos/1.jpeg\n\n\n5\nA\n25.13509\n2949,0,2995,43\nmedia/photos/1.jpeg\n\n\n6\noe\n40.92468\n2446,99,2500,116\nmedia/photos/1.jpeg\n\n\n\n\n\nTo address this issue over this we are going to filter out everything with a confidence level below 90:\n\nninty_plus &lt;- text_data[which(text_data$confidence &gt; 90, any),]\n\n\n\n\n\n\n…1\nword\nconfidence\nbbox\nsource\n\n\n\n\n4\nJ\n95.34794\n2892,0,2930,98\nmedia/photos/1.jpeg\n\n\n29\n|\n90.71518\n1867,1123,1877,1260\nmedia/photos/1.jpeg\n\n\n83\n|\n90.63419\n1234,1856,1237,1891\nmedia/photos/1.jpeg\n\n\n133\n|\n90.00334\n654,2151,658,2174\nmedia/photos/1.jpeg\n\n\n134\n|\n90.47010\n791,2088,798,2192\nmedia/photos/1.jpeg\n\n\n161\n=\n92.46490\n2321,2254,2347,2258\nmedia/photos/1.jpeg\n\n\n\n\n\nThis is looking better, but there is still lots of useless data so we are only going to keep ‘words’ with more than 1 character.\n\nninty_plus_words &lt;- ninty_plus[which(nchar(ninty_plus$word) &gt; 1, any),]\n\n\n\n\n\n\n\n\n\n\n\n\n\n…1\nword\nconfidence\nbbox\nsource\n\n\n\n\n2274\nSS\n90.11664\n1084,1280,1155,1323\nmedia/photos/5.jpeg\n\n\n2357\nPASSENCERS\n91.67908\n938,1690,1108,1719\nmedia/photos/5.jpeg\n\n\n2358\nMUST\n96.32262\n1124,1697,1193,1713\nmedia/photos/5.jpeg\n\n\n2359\nNOT\n96.32262\n1209,1701,1255,1715\nmedia/photos/5.jpeg\n\n\n2373\nCROSS\n96.32278\n898,1719,987,1751\nmedia/photos/5.jpeg\n\n\n2374\nTHE\n96.39224\n1005,1723,1057,1737\nmedia/photos/5.jpeg\n\n\n\n\n\nNow that we have our words we extracted from our images we can create a data visualization from them. As both a bit of EDA and an straightforward bit of code, I’m going to make a wordcloud.\n\nlibrary(wordcloud2)\n\n# all we have to do is count up how many times each word occurs \n\nwordcloud_data &lt;- as.data.frame(table(ninty_plus_words[,c(\"word\")] ))\n\n# voila! \n\nwordcloud2(wordcloud_data)\n\n\n\n\n\n\n\nClass Challange!\nI created this dataset without a motivation of linking the data I collected to a larger issue.However, we could think about some ways in which this could be made to link the personal and political. To trial this out I have linked the data we have just worked with to some external datasets.\nAs a challenge for this class I would like you to download this csv and see what data visulizations you can produce?\nI have included 5 new variables linked via the location each picture was taken. These are:\n\nAverage house price.\nAverage time it takes to walk to a hospital.\nIndex of Multiple Deprivation by rank and decile.\nUrban/rural classification.\n\nWork with the data however you want!\nYou can download the .csv of all the EXIF data here or a copu of all the photographs here.\nPlease also feel free to merge in add, mash-up, or play around with any of the data!\nAs ever please ask us questions!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Images as Data</span>"
    ]
  }
]